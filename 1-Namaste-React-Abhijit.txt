Episode 1 :
VS Code is used EMMET - What is this is generate some code for you in VS code 
If we write html:5 it generate the basic html for you 

1. We see how we can create the basic hello world program using the html (created index.html file and in h1 tag added the text)
2. Here we see how we can create the basic hello world program using the Javascript  (Checkout the solution in the index.html file)
3. Now how we can create the basic hello world program using the React 
4. To inject the react into our project we use the CDN react (CDN - Content delivery network)
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script> -> this will inject the react 
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> ->this will inject the reactDom we use to modify the DOM

After including this script tag then we have react inside our project now the browser will understand what is react.
-Now we have injected the react if we go to the browser and inspect it and type the react we will see the lots of things we get. (children, component, etc)
-If we write the ReactDOM in console you will see the different functions give by the react DOM.
-console.warn("This heading is a react element and we can see in the console the react element will be printed",heading) 
-if we print the heading we can see the react element and it has he props the props means 
{
    "id": "xyz",
    "children": "Hello World form React!"
}
this that we have passed as a parameter there
const heading = React.createElement("h1", {id:"xyz"}, "Hello World form React!");


EX:The below structure we have created using the react 
<div id = "parent">
       <div id = "child">
           <h1>I'm H1 Tag means heading tag</h1>
        </div>
 </div>

 const parentElement = React.createElement(
  "div",
  { id: "parent" },
  React.createElement(
    "div",
    { id: "child" },
    React.createElement("h1", {}, "I am an h1 tag")
  )
);
This is the structure 

- And the ReactElement is basically is a object ReactElement(Object) = HTML (Browser understand)
- The react element become the HTML that browser understand while rendering into the DOM it converts the react code into the DOM (EX: root.render(parentElement);)

-const parentElement = React.createElement(
  "div",
  { id: "parent" },
  React.createElement(
    "div",
    { id: "child" },
    [
      React.createElement("h1", {}, "I am an h1 tag"),
      React.createElement("h2", {}, "I am an h2 tag"),
    ] // if we want to add one more sibling to it then we need to add that in the array
  )
); 
To avoid this complex structure we have JSX
- JSX will make our life easy when we have to create the tagsÂ±


Episode 2:
-npm npm basically a package manager where all the package are there
-Now to initialize the npm in our app then we need to do the (npm init)
-It will generate the package.json file this is the basically a configuration for npm
-Why we need this package.json the package we install is also knows as the dependencies npm manage that and it will manage that in the package.json file
-npm install -D parcel we have install the parcel to bundle the packages as we can see the -D we have use there its a dev dependencies means it is required in the development env 
-When we install the parcel then we will see the new files are added package-lock.json file and node_modules
-What is difference between package.json and package-lock.json file package.json keeps track of version of packages that we install and package-lock.json keep track of exact version that is we install its will lock the exact version of the package that we install 
-If we have package.json and package-lock.json then we can regenerate the node modules that is why we don't need to push the node_modules to the git 
-We can recreate the node_modules using the command (npm install)
-"parcel": "^2.12.0" as you can see the ^ this sign it will get the minor update and if we see Â§ tild sign then it will take the major update
-(npx parcel index.html) we ignite our app using this command.
-What is npx just like npm we have npx. npx means executing our package whenever we have to execute our package we use the npx <package name>
-After igniting the app the lots of things are happened
-To inject the react into our app we use the CDN links there is another way to inject the react into our app is using npm using node package manager
-The CDN links are not good way to initialize the react app.
-Now to install the react into our app we have to use the command (npm install react) and we need to install the react DOM also (npm install react-dom)
-If we check the package.json we will see the react and react-dom is installed properly 
"dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  }
-Now we are getting an error its not able to find out from where the react is coming for because previosuly we use the CDN links now we are installing the packages 
-So we need to import the react 
-import React from "react"; we import the react so form where it is coming from its coming form node_module from react file so thats the meaning of import 
-If we change something in code we will see that change in browser automatically we dont need to reload the page this happend because we use the parcel in our app

# Parcel
-Dev Build
-Local Server
-HMR = Hot Module Replacement
-It Uses file watching algorithm - its written in C++
-Caching = Faster Build 
-Image Optimization
-Minification 
-Bundling
-Compressing
-Consistent Hashing
-Code Splitting
-Differential Bundling - supports older browsers
-Diagnostic 
-Error Handling 
-Https
-Tree Shaking - remove unused code
-Different dev and prod bundles

-If we want to do the prod build then we need to use the command like (npx parcel build index.html)
As we hit this command then we get the error
ðŸš¨ Build failed.

@parcel/namer-default: Target "main" declares an output file path of "app.js" which 
does not match the compiled bundle type "html".

  /Users/abhijit/Desktop/Namaste-React/package.json:5:11
    4 |   "description": "This is Namaste-React Abhijit",
  > 5 |   "main": "app.js",
  >   |           ^^^^^^^^ Did you mean "app.html"?
    6 |   "scripts": {
    7 |     "test": "Jest"

  ðŸ’¡ Try changing the file extension of "main" in package.json.

-so to resolve this error we need to remove the "main": "app.js", this from the package.json because its not the entry point of our application we have write there in cmd as index.html its not matching there 
npx parcel build index.html
âœ¨ Built in 839ms
dist/index.html                345 B    310ms
dist/index.d8c12c77.css         85 B     31ms
dist/index.268a7a54.js     139.24 KB    179ms

-It will build the all dist file in the dist we will see it will compresseed everything and now our code is production ready it will minify our code  
-We have browser list where we can add for which browser our app will support
(https://browserslist.dev/?q=bGFzdCAyIHZlcnNpb25z) checkout this site


Episode 3:
we can create a script to build our production ready app then we need to write the script there in the package.json
  "scripts": {
    "start": "parcel index.html",
    "test": "Jest"
  }
  This script is used to create a dev build 
  -Lets create a script for building a production
   "scripts": {
    "start": "parcel index.html",
    "build": "parcel build index.html"
    "test": "Jest"
  }
  -this script is used to build the production app
  -Now we have created the script now we don't need to write the (npx parcel index.html) to build our app.
  -Suppose if we got to the company and you don't know how to build the application then go to the package.json file and you will find the scripts there and you will see the command to run the code
  -Now to run the application so what command we need to hit 
   "scripts": {
    "start": "parcel index.html",
    "build": "parcel build index.html"
    "test": "Jest"
  }
-To run the application we need to use the command (npm run start) and if you hit the enter it will do the same things that our run cmd do 
npm run start
> namaste-react@1.0.0 start
> parcel index.html
Server running at http://localhost:1234
âœ¨ Built in 514ms

-As you can see our application is running we just need so see the package.json and look for the script and check what is written in the start section and hit (npm run <script>) your application will run successfully.
or you can do the (npm start) also it will start the application it will same as the (npm run start)
-I have created the new app1.js file 
-JSX React = const jsxHeading = <h1 id="tag">This is h1 tag using JSX ðŸš€</h1>; // This is not HTML this is JSX. JSX is different than HTML its HTML like syntax
const root = ReactDOM.createRoot(document.getElementById("root2"))
root.render(jsxHeading)
-As you can see the h1 tag we have written that is JSX
-JSX React (transpiled before it reaches the JS engine) - this is done by parcel - parcel will do this work form the babel as we save the code babel will convert the code into the react code (react understandable code).
-JSX => React.createElement => ReactElement.JS Object => HTMLElement(render)
-This is how the code will work in background
-If we want to give the class name in the JSX the we need to give like this => className="head"
-If we want to write the multiple lines the babel code then we need to write it into the () parenthesis
EX: const jsxHeading = (
  <h1 className="head" id="tag">
    This is h1 tag using JSX ðŸš€
  </h1>
); 
-React components = are the building blocks of the react application.
-There are two types of components in react 
1.Class Based Components - Old way of writing react components
2.Functional Components - New way of writing react components

-React Functional Components
EX:
//Functional components
const FunctionalComponent = () => {
    return <h1>Namaste Guys React Functional Component</h1>
};
-This is the react functional component with return the JSX code
-We will use the functional component all across the places
-To render the functional component we need to use the 
root.render(<FunctionalComponent/>); method
-<FunctionalComponent/> like this we need to add to render the functional component
-How we can write the JavaScript code inside the Function component
EX:const FunctionalComponent = () => (
    <div id="container">
        <h2>{100 + 200}</h2> // Using the {} these curly braces we can write the javascript code in the function component
        <h1>THIS IS FUNCETIONAL COMP</h1>
    <h1 className="functionComp">Namaste Guys React Functional Component</h1>
  </div>
);
-This is how we can write the Javascript in the functional component
-How we can render the component inside the component =>
EX:const Title = () => (
    <h2>This is how we can render the data in the functional comp using</h2>
);

const FunctionalComponent = () => (
  <div id="container">
    <Title /> // Here we render the component inside the component
    <h2>{}</h2> // Using the {} these curly braces we can write the
    javascript code in the function component
    <h1>THIS IS FUNCETIONAL COMP</h1>
    <h1 className="functionComp">Namaste Guys React Functional Component</h1>
  </div>
);

-Lets see the example how we can render the text or something in the functional component with example 
-<> ... </> is a React Fragment. It allows you to group multiple elements without adding an extra node to the DOM.
-If we are getting the data form the API like 
EX: const data = api.getData();
-Then we can use the {} these curly braces to render the data in the functional component
EX: const FunctionalComponent = () => (
  <div id="container">
    <Title /> // Here we render the component inside the component
    <h2>{data}</h2> // Using the {} these curly braces we can write the
    javascript code in the function component
)
-If attacker get access to run some JavaScript code in your browser what we can do this type of attack is knows as cross-site scripting (XSS)
-But JSX is so amazing it wil take care of this type of attack it prevent cross-site scripting (XSS) for you 


Episode 4 :
-Here we are building the food ordering app in React
-So what component my app have 
1.Header
-Logo
-Nav Icon
2.Body
-Search Bar
-RestaurantsContainer
3.RestaurantCard
-Image
-Name
-Cuisine
-Rating
-Order Now
4.Footer
-Copyright
-Contact Us
-links
-Address
-So in our project we have created the cards and we have hard coded it and created the multiple copies 
EX: const RestaurantCard = () => {
  return (
    <div className="res-card">
      <img
        className="res-img"
        src="https://images.pexels.com/photos/2338407/pexels-photo-2338407.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2"
      ></img>
      <h3 className="res-name">Kakke Da Paratha</h3>
      <h4>Biryani, North Indian, Asian</h4>
      <div className="details">
        <div className="rating">4.4</div>
        <div className="delivery-time">38 Min</div>
      </div>
    </div>
  );
}
-const Body = () => {
  return (
    <div className="body">
      <div className="search">Search</div>
      <div className="resto-container">
        <RestaurantCard />
        <RestaurantCard /> <RestaurantCard /> <RestaurantCard />{" "}
        <RestaurantCard /> <RestaurantCard /> <RestaurantCard />{" "}
        <RestaurantCard />
        <RestaurantCard /> <RestaurantCard /> <RestaurantCard />{" "}
        <RestaurantCard /> <RestaurantCard /> <RestaurantCard />{" "}
        <RestaurantCard />
      </div>
    </div>
  );
};
This is how we have displayed here and now we want this card is dynamic means we have to show the different data to the each card so how we can do that we can do that using the concept called as props it is a short form for the properties (properties is something which we can pass to the component)
-So what is the props the props is argument to the functional component if we want to dynamically pass the data to the functional component then we can do that using the props
EX:
const RestaurantCard = ({
  resName,
  cuisine,
  rating,
  deliveryTime,
  imageUrl,
}) => {
  return (
    <div className="res-card">
      <img className="res-img" src={imageUrl}></img>
      <h3 className="res-name">{resName}</h3>
      <h4>{cuisine}</h4>
      <div className="details">
        <div className="rating">{rating}</div>
        <div className="delivery-time">{deliveryTime}</div>
      </div>
    </div>
  );
};
-This is how we destructure the properties
it means 
const {resName, cuisine} = props
-So its props
-Lets see the Swiggy API calls there are lots of complex API call we will see if we see the swiggy API this concept is know as (config-driven-UI)
-So what is the config-driven-UI it means we can render the UI based on the config data that is coming from backend 
EX: If we see the swiggy offers there is different offers for the different location so the carosole also different for the different location so we can render the carousel based on the config data that is coming from backend location 
-It simply means we can render the UI based on the config data that is coming from  (our ui will change based on data that is coming form backend)
-So to render the data we have loop that 
EX: const Body = () => {
  return (
    <div className="body">
      <div className="search">Search</div>
      <div className="resto-container">
        {restaurantData.map((restaurant, index) => (
          <RestaurantCard
            key={index}
            resName={restaurant.resName}
            cuisine={restaurant.cuisine}
            rating={restaurant.rating}
            deliveryTime={restaurant.deliveryTime}
            imageUrl={restaurant.imageUrl}
          />
        ))}
      </div>
    </div>
  );
};
like this as you can see there is index we have added if we loop the data we need to pass some unique key 
EX: Suppose we have root element and we have child so what happen is react optimizes its render cycle so we need to uniquely represents out child because suppose a new restaurant comes in at the first place and we don't given the the id to the child then react will rerender all the cards. react does not know which card is new and which card is old so it will rerender all the cards. so to overcome this problem we have to give the unique key to the child element.
-So as you can see in the code we have given the index as a key to the child element. But react say that never use the index as a key because it is not unique. so we have to use the id of the restaurant as a key.

Episode 6 :
-What is Monolithic architecture => we have API , UI, Auth, DB, SMS code inside it so basically we have all the things inside it. it is not good for the scalability and maintainability.
-Monolithic architecture is a software design where an entire application is built as a single, unified codebase. All components (UI, business logic, data) are combined and tightly coupled, leading to simple development and deployment for small applications. However, it can be challenging to scale, update, and maintain because changes affect the whole system, making it less flexible for larger projects compared to modular microservices architecture.
-What is Microservices architecture => in the microservices architecture we have different services like API, UI, Auth, DB, SMS code. So we have different services for different things. It is good for the scalability and maintainability.
-Microservice architecture is a software design approach where an application is built as a collection of small, independent services, each responsible for a specific function. These services communicate with each other through well-defined APIs and can be developed, deployed, and scaled independently. This design allows for better scalability, flexibility, and easier updates or maintenance since changes to one service do not directly impact others. Microservices are often used in larger, complex applications to improve development speed and resilience but can introduce challenges in terms of network communication and overall system management.
-So now how we can fetch the data form backend so there are two approaches for this 
1. As soon as the page load then we call the api and we wait for the data to come then we load the page there 
2. As soon as the page load we just quickly render what ever is there. whatever is there we will just quickly render it 
-In react we will always go with the second approach this is the better approach as soon as api update we will update our Ui too 
-Now to use this we need to use the react hook called useeffect()
-So this useEffect takes two arguments one is the function and the second is the dependency array.
-So when that function will call that we pass as a argument to useEffect() and the second argument it is called after your component render 
-As you can see here first the body is rendered and then the useEffect() is called and then the useEffect() is called and then the body is rendered again
EX:  useEffect(() => { 
      console.log("Use effect called"); 
      }, []);
      console.log("Body component rendered");     
-So why we use useEffect() because we want to do some side effect like fetching data from the server or setting up a timer or subscribing to a channel or something like that. and it is helpful to implement the second approach 
-Then we fetch the data in the useEffect()
EX:const fetchSwiggyData = async () => {
    try {
      const response = await fetch(
        "https://www.swiggy.com/dapi/restaurants/list/v5?lat=19.07480&lng=72.88560&is-seo-homepage-enabled=true&page_type=DESKTOP_WEB_LISTING"
      );
      if (response.ok) {
        const updatedSwiggyData = await response.json();
        console.log(updatedSwiggyData); // Log the full response to inspect its structur
        // Extracting the specific data you need (cards) from the API
        const restaurants =
          updatedSwiggyData?.data?.cards[0]?.card?.card?.gridElements
            ?.infoWithStyle?.info || [];
        setSwiggyData(restaurants);
      } else {
        console.error("Error fetching data:", response.statusText);
      }
    } catch (error) {
      console.error("Fetch error:", error);
    }
  };
-? the question mark we have added that is optional chanining operator
-So this is how we can fetch data from an API and then use that data to update the state in the useEffect() hook.
-Now if we call the api but the api is taking some time to load the data to get the data then what people used to do is they show the loader but its not good user experiance the good user experiance is to show the shimmer UI read about this its a good practice. Instead of showing the loader we have to show the shimmer UI there 
-Now lets create a shimmer UI 
-We have created the shimmer UI and we show the cards on it 
-Now we have to create a button if we hit the login button then we need to change to logout so how we can do that there
EX:
let btnName = "login";
 <button
      type="button"
      class="button button3"
      onClick={() => {
      btnName = "logout";
      console.log(btnName); 
      }}
></button>
-But here we click on the button login button and if we click that button it will change to the logout but in our UI we cant see the logout because our UI is not updated there so to update that UI we need to refresh the page so that can be done using the useState() hook
-So if we want to update it on UI we use the hook 
EX: 
 let [btnNameReact, setBtnNameReact] = useState("Login");
  <button
      type="button"
      class="button button3"
      onClick={() => {
      setBtnNameReact("Logout");
      console.log(setBtnNameReact);
    }}
  >
  {btnNameReact}
  </button>
-useState this useState is a hook and it is used to update the UI it will take two parameter first one is the initial value and second one is the function which will be called when we click on the button and then on click of the button it will update the UI and we can see the header is updated to the logout
-As soon as we click on the button it will render the whole Header component.
-Now we have to implement the search functionality so if we do the search it has to search for the restaurant 
-  <input
            type="text"
            className="search-input"
          placeholder="Search for restaurants"
          value={searchText}
          onChange={(event) => setSearchText(event.target.value,   console.log(searchText))
        
          }
          />
        <button type="btn" onClick={({
        
        })}>Search</button>
-So this is our search box and the search button as we type some text then it will rerender our body component and it will show the restaurants which are matching with the search text so we type "A" also then it will again rerender our component.
-Whenever the state variable updates then react trigger the Reconciliation cycle (re-render) the component.
-So there is an interview question why react is fast - so the virtual dom is the reason behind it. there is react fiber the new Reconciliation algorithm which find out the difference between the old dom and the new dom and then it will only update the changed dom. and update the dom only required and the portion of the dom only render 

Episode 7 :
-Now we will see how we can do the routing in our react application. so we will use react-router-dom package for routing in our react application.
-If there is no dependencies array = use effect called on every render.
-If dependency array is empty = [] => useEffect is called on initial render only(just once).
-If dependency array is [btnNameReact] => called everytime btnNameReact is updated.
-Now lets see the react router library. so we will use the <BrowserRouter> and <Routes> and <Route> components for routing in our react application.
-So to install the react-router-dom package we will use the command npm install react-router-dom@6.
-You can check this site it contain all the useful things for the routing = https://reactrouter.com/ 
-To do the routing we need to create the routing configuration createBrowserRouter and Routes and Route components.
-To do the routing configuration we need to provide the 
import { createBrowserRouter, RouterProvider } from "react-router-dom";
const appRouter = createBrowserRouter([
  {
    path: "/",
    element:<App/>
  },
  {
    path: "/about",
    element:<About/>
  },
  {
    path: "/contact",
  }
]);
-React-router-dom gives you the access 
import { useRouteError } from "react-router-dom"; using this hook we can give the more details of the error using this hook we can tell the specific details to the user.
Error Page: 
const Error = () => {
    const err = useRouteError();
    console.log(err.error.message);
    console.log(err.error.stack)
  return (
    <div>
      {" "}
      <h1 className="ErrorCss">Oops!! ðŸš€</h1>
      <h2 className="ErrorCss">
        Something went wrong in the routing please check the routing URL
      </h2>
      <h3 className="ErrorClassNew">{err.error.message}</h3>
      <h5 className="ErrorClassNew">{err.error.stack}</h5>
    </div>
  );
};
export default Error;
-So this is our error component and we are using the useRouteError hook to get the error details and we are printing the error details in the console and also in the UI.
-Ex: {
    path: "/",
    element: <AppLayout />,
    errorElement: <Error />, // here we render the error page when the routes failed then this page will show there.
    children: [
      { path: "/", element: <Body /> },
      { path: "/data", element: <DataPage /> },
      { path: "/about", element: <About /> },
      { path: "/contact", element: <Contact /> },
    ],
  },
-Now if we go to the any page in our routing we need one header component is fix there in that page like - 
<Header />
this header we need Fixed
<Footer />
-So this header and footer we need to fix in all pages 
EX: 
const AppLayout = () => (
  <div>
    <div className="App">
      <Header />
      <Outlet />
      <Footer />
    </div> 
  </div>
);
-So this outlet will do render the children component as we route and it will keep header and footer there 
export const appRouter = createBrowserRouter([
  {
    path: "/",
    element: <AppLayout />,
    errorElement: <Error />,
    children: [
      { path: "/", element: <Body /> },
      { path: "/data", element: <DataPage /> },
      { path: "/about", element: <About /> },
      { path: "/contact", element: <Contact /> },
    ],
  },
]);
-So this is the example of how we can create the children route and we load the children route inside the Outlet.
-In react how we can route to the different page if we use the <a href ="/about"> tag we can route to the different page but this is not the best way to do this way the page is load if we route so we can use the Link tag to do this.
-The react application is SPA (Single page application) where app.js is our single page and we just rendering the other component there in that page. like wise
-In react there are two types of routing.
1. Client Side Routing - Here in react we use the client side routing and it will not load the page it will just render the component inside the page so it will not load the page so its client side routing.
2. Server Side Routing - If we make the api call then the aboutUs page is load data is coming form server in the network call we will see that data is coming from server so its server side routing.
-Client Side Routing is the routing that is done on the client side and it is done using the Link tag and it is done using the react-router-dom library.
-Server Side Routing is the routing that is done on the server side and it is done using the express library and it is done using the react-router library.
-To route based on the resId then we need to capture the resId form the params so we have one hook to capture it. ie useParams hook. 
EX:
import { useParams } from "react-router-dom";
const { resId } = useParams();
console.log("This is the resId",resId)



Episode 8:
-We will see the class based component in react and we will see the difference between the class based component and the functional component.
-Class based component is older way of creating the component.
-It will ask in interview lot (lots of companies works on the class based component).
-Lets see the example of the class based component. 
EX: 
class UserClass extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
-This is the class based component and it will have render method that return the piece of JSX.
-So this is our class based component.
-Lets see the functional component. in the latest version we will use the functional component.
EX:
const User = () => {
  return <h1>Hello, {props.name}</h1>;
}
-So this is our functional component that we use.
-In the functional component we have to pass the props in the component. 
EX:
User.js
import "./User.css"
const User = (props) => {
    return (
        <div className="user-card">
            <h2>Name : { props.name}</h2>
            <h3>Location : Pune</h3>
            <h4>Contact : abhijitagore2000@gmail.com</h4>
        </div>
    )
}
export default User;

About.js
import User from "./User"
const About = () => {
    return (
        <>
            <div>
                <h1> About </h1>
                <h2>This is Abhijit Gore site</h2>
            </div>
            <User name={ "Abhijit Gore (Software Developer, DevOps Engineer)"} />
        
        </>
    )
}
export default About
-In the class based component we have to use the props in the render method.
EX:
class User extends React.Component {
    render() {
        return (
            <div className="user-card">
                <h2>Name : {this.props.name}</h2>
                <h3>Location : Pune</h3>
                <h4>Contact : abhijitagore2000@gmail.com</h4>
            </div>
        )
    }
}
export default User;

class About extends React.Component {
    render() {
        return (
            <>
                <div>
                    <h1> About </h1>
                    <h2>This is Abhijit Gore site</h2>
                </div>
                <User name={ "Abhijit Gore (Software Developer, DevOps Engineer)"} />

            </>
        )
    }
}
export default About

-So as you can see in the above example this is how we can receive the props in the class based component.
-There is on method in the react class based component which is componentDidMount() which is used to fetch the data from the api or any other source.
EX:
class User extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            users: []
        }
    }
    componentDidMount() {
        fetch('https://jsonplaceholder.typicode.com/users')
            .then(response => response.json())
            .then(data => this.setState({ users: data }))
    }
    render() {
        return (
            <div>
                <h1>Users</h1>
                <ul>
                    {this.state.users.map(user => <li key={user.id}>{user.name}</li>)}
                </ul>
            </div>
        )
    }
}
export default User;

-So as you can see in the above example we are fetching the data from the api and setting the state with the data.
-We can check the lifecycle of react method here below
-https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
-Now we are calling the github user api to fetch the data and display it in the component.
EX:
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch(
        "https://api.github.com/users/abhijit-gore24"
      );
      const data = await response.json();
      setUserData(data);
    };

    fetchData();
  }, []);

-This is how we can call the user api here and we will display the user details here.

Episode 9:
-Now we will see how we can optimize our app.
1. Optimize Rendering
a. Use React.memo
Prevent unnecessary re-renders of functional components by wrapping them with React.memo.
Example:
javascript

const MemoizedComponent = React.memo(MyComponent);
b. Use useCallback and useMemo
Cache functions and computations to avoid re-creation on every render.
javascript

const memoizedValue = useMemo(() => expensiveComputation(data), [data]);
const memoizedCallback = useCallback(() => handleEvent(id), [id]);
c. Avoid Anonymous Functions in Props
Pass predefined functions instead of inline arrow functions in JSX.
javascript

const handleClick = () => { ... };
<Button onClick={handleClick} />;
2. Code Splitting and Lazy Loading
Use React's lazy loading and dynamic imports to split code into smaller bundles.

javascript

const LazyComponent = React.lazy(() => import('./LazyComponent'));
Use React Suspense for fallback rendering while the component loads.

javascript

<React.Suspense fallback={<div>Loading...</div>}>
  <LazyComponent />
</React.Suspense>
3. Optimize State Management
a. Lift State Up Wisely
Keep state as local as possible; avoid hoisting it unnecessarily.
b. Use Context API Only When Necessary
Avoid overusing the Context API for frequently changing data to prevent unnecessary re-renders.
c. Use Efficient State Libraries
Use libraries like Zustand, Redux Toolkit, or MobX for complex state management when required.
4. Efficient DOM Manipulations
a. Use React.Fragment
Avoid unnecessary wrapper divs.
javascript

<React.Fragment>
  <Component1 />
  <Component2 />
</React.Fragment>
b. Virtualize Long Lists
Use libraries like react-window or react-virtualized to render large lists efficiently.
5. Optimize Asset Loading
a. Use Proper Image Formats
Use modern formats like WebP or AVIF for images.
Use srcset to serve images of appropriate resolutions.
b. Lazy Load Images
Use libraries like react-lazyload or implement lazy loading manually.
6. Avoid Unnecessary Re-Renders
a. Use key Properly in Lists
Always use a unique key when rendering lists to avoid React reusing the wrong DOM nodes.
b. Reduce Prop Drilling
Use Context API or state libraries to avoid passing down props deeply.
7. Optimize Styles
a. Use CSS-in-JS Wisely
Use libraries like Styled-Components or Emotion but avoid overusing dynamic styling, which can impact performance.
b. CSS and JavaScript Separation
For simple apps, prefer external CSS for faster render cycles.
8. Avoid Memory Leaks
Clean up subscriptions, timers, or event listeners in useEffect.
javascript

useEffect(() => {
  const timer = setInterval(() => { ... }, 1000);
  return () => clearInterval(timer);
}, []);
9. Optimize Network Requests
a. Debounce or Throttle Events
Reduce the frequency of expensive events like onScroll or onSearch.
javascript

const debouncedFunction = debounce(() => performAction(), 300);
b. Use SWR or React Query
Cache and fetch data efficiently.
javascript

import useSWR from 'swr';
const { data, error } = useSWR('/api/data', fetcher);
10. Build and Deployment Optimization
a. Tree Shaking
Remove unused code by using ES modules and tools like Webpack or Rollup.
b. Minify and Compress
Use tools like Terser and Brotli/Gzip compression for production builds.
c. Analyze Bundle Size
Use tools like Webpack Bundle Analyzer to identify large dependencies and reduce them.
d. Serve Static Assets Efficiently
Use CDNs and cache static files.
By following these strategies, your React application will perform faster, be more maintainable, and scale better as it grows. Let me know if you'd like specific examples or guidance on any of these techniques!

-We can create our custom hooks to fetch the data we will create a separate file to fetch the data and we can use that in the component.
-Now how we can use the lazy loading in the react how we can load the component when it is required. 
EX: 
import React, { Suspense } from 'react';

// Lazy load components
const About = React.lazy(() => import('./components/About'));
const Contact = React.lazy(() => import('./components/Contact'));

function App() {
  return (
    <div className="App">
      <h1>React Lazy Loading Example</h1>

      <Suspense fallback={<div>Loading About Component...</div>}>
        <About />
      </Suspense>

      <Suspense fallback={<div>Loading Contact Component...</div>}>
        <Contact />
      </Suspense>
    </div>
  );
}

export default App;

-Explanation
React.lazy:
The React.lazy function takes a dynamic import() statement and returns a promise. This promise resolves when the component is loaded.

-Suspense Fallback:
While the lazy-loaded component is being fetched, the Suspense component displays a fallback UI (e.g., a loading spinner or a message).

Lazy Loading with Routes
If youâ€™re using react-router-dom, you can also lazy load components for specific routes.

Example:
import React, { Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

const About = React.lazy(() => import('./components/About'));
const Contact = React.lazy(() => import('./components/Contact'));

function App() {
  return (
    <Router>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/about" element={<About />} />
          <Route path="/contact" element={<Contact />} />
        </Routes>
      </Suspense>
    </Router>
  );
}

export default App;

Episode: 10
-How we can build our app make beautiful and easy to use
-There are different ways to write the CSS. 
1.We have index.css file and we can write all the CSS in that file.
2.Second way to use css is Sass so CSS is special way to write the CSS. basically it is CSS with some extra features. it adds the super power to the CSS.

SCSS and SASS are both syntaxes of Sass (Syntactically Awesome Stylesheets), a powerful CSS preprocessor. They enhance CSS by providing advanced features like variables, nesting, mixins, inheritance, and more, which make styling web applications more manageable and efficient.

SASS (Syntactically Awesome Stylesheets)
SASS Syntax: The original syntax of Sass.
Key Features:
Uses indentation instead of curly braces {} and semicolons ;.
Cleaner and more concise but less similar to regular CSS.
File Extension: .sass
Example:
sass
// SASS example
$primary-color: #3498db

body
  font-family: Arial, sans-serif
  background-color: $primary-color

  SCSS (Sassy CSS)
SCSS Syntax: A newer, more CSS-like syntax for Sass.
Key Features:
Uses curly braces {} and semicolons ;, similar to CSS.
Easier to transition from regular CSS to SCSS.
More widely used in modern projects.
File Extension: .scss
Example
// SCSS example
$primary-color: #3498db;

body {
  font-family: Arial, sans-serif;
  background-color: $primary-color;
}
-How we can use the tailwind in our app that we see, tailwind is amazing 

-Typography
text-{size}: Sets font size (e.g., text-lg for large text).
font-{weight}: Sets font weight (e.g., font-bold for bold text).
text-{color}: Sets text color (e.g., text-red-500 for red text).
text-center | text-left | text-right: Aligns text.
leading-{value}: Adjusts line height (e.g., leading-relaxed).
tracking-{value}: Adjusts letter spacing (e.g., tracking-wide).

-Colors and Background
bg-{color}: Sets background color (e.g., bg-blue-500 for blue).
bg-opacity-{value}: Sets background transparency (e.g., bg-opacity-50).
hover:bg-{color}: Changes background on hover (e.g., hover:bg-green-400).

-Spacing
p-{value}: Padding (e.g., p-4 adds padding all around).
px-{value} / py-{value}: Horizontal/vertical padding.
m-{value}: Margin (e.g., m-2 for margin on all sides).
space-{x|y}-{value}: Adds space between child elements (e.g., space-y-4).

-Flexbox & Grid
flex: Makes an element a flex container.
flex-{row|col}: Sets flex direction (e.g., flex-col for column layout).
justify-{start|end|center|between|around}: Aligns items horizontally.
items-{start|end|center|stretch}: Aligns items vertically.
grid: Enables CSS grid layout.
grid-cols-{n}: Defines grid columns (e.g., grid-cols-3 for 3 columns).

-Sizing
w-{value}: Width (e.g., w-1/2 for half width).
h-{value}: Height (e.g., h-64 for fixed height).
max-w-{value}: Maximum width (e.g., max-w-screen-lg).
min-h-{value}: Minimum height (e.g., min-h-screen).

-Borders & Shadows
border-{size}: Sets border width (e.g., border-2).
border-{color}: Sets border color (e.g., border-gray-300).
rounded-{value}: Rounds corners (e.g., rounded-full for a circle).
shadow-{value}: Adds box shadow (e.g., shadow-lg for large shadow).

-Positioning
relative | absolute | fixed: Sets position.
top-{value} | left-{value}: Positions element (e.g., top-4 for 1rem from the top).
Display & Visibility
block | inline-block | hidden: Controls display type.
visible | invisible: Controls visibility.
z-{value}: Sets z-index (e.g., z-50).

-Animation
transition: Enables transition effects.
duration-{value}: Sets duration (e.g., duration-300 for 300ms).
ease-in | ease-out: Defines easing for transitions.

-Utilities
overflow-{auto | hidden | scroll}: Controls overflow behavior.
cursor-{value}: Sets cursor type (e.g., cursor-pointer for clickable).
opacity-{value}: Controls element transparency (e.g., opacity-50).


Episode: 11
-Now we will see the higher order component in react
-higher order components are the components that takes a component as a parameter and returns a new component 
EX:
const withPromotedLabel = (RestaurantCard) => {
  return () => {
    return (
      <div className="res-card">
        <div className="promoted">Promoted</div>
        <RestaurantCard />
      </div>
    );
  };
};
-withPromotedLabel is our higher order component and RestaurantCard is the component that we are passing to it and now it will return a new component with the promoted label
-We see the proper debugging  in react we will use the react developer tools